#!/usr/bin/python
# Tracks provides tools for analyzing large trajectory files.
# Copyright (C) 2007 Toon Verstraelen <Toon.Verstraelen@UGent.be>
#
# This file is part of Tracks.
#
# Tracks is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# Tracks is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
# --


from ccio.psf import PSFFile
from tracks import dist_track, bend_track, dihed_track, dump_track, parse_slice, AtomFilter, TrackNotFoundError, log
import numpy, os
from optparse import OptionParser


usage = """Usage: %prog [options] prefix connectivity.psf

%prog computes all the internal coordinates for the Cartesian tracks with the
given prefix. The list of internal coordinates is taken from the connectivity
file. Currently only the psf format is supported for the latter. The output is
written to the following kinds of files:

prefix.dist.${index1}.${index2}
prefix.bend.${index1}.${index2}.${index3}
prefix.dihed.${index1}.${index2}.${index3}.${index4}

%prog -h prints out all available options."""

parser = OptionParser(usage)
parser.add_option(
    "-s", "--slice", default="::",
    help="Subsample the input tracks with the given slice start:stop:step "
         "where start, stop and step must be integers or can be omitted. "
         "The slice interpretation is pythonic. [default=%default]",
)
parser.add_option(
    "-a", "--filter-atoms",
    help="Only consider internal coordinates in which on of the atoms indexes "
         "is listed in FILTER_ATOMS. FILTER_ATOMS is a comma separated list of "
         "of integers. Counting starts at zero.",
)
parser.add_option(
    "-q", "--quiet", action="store_false", dest="verbose", default=True,
    help="Don't print any output."
)
(options, args) = parser.parse_args()


log.verbose = options.verbose
if len(args) == 2:
    prefix, path_psf = args
else:
    parser.error("Expecting two arguments.")

sub = parse_slice(options.slice)
psf = PSFFile(path_psf)
atom_filter = AtomFilter(options.filter_atoms)

for index1, index2 in psf.bonds:
    if atom_filter(index1, index2):
        try:
            name = '%s.dist.%07i.%07i' % (prefix, index1, index2)
            dump_track(name, dist_track("%s.%07i" % (prefix, index1), "%s.%07i" % (prefix, index2), sub))
            log("DONE %s" % name)
        except TrackNotFoundError, e:
            log("WARNING %s" % str(e))
for index1, index2, index3 in psf.bends:
    if atom_filter(index1, index2, index3):
        try:
            name = '%s.bend.%07i.%07i.%07i' % (prefix, index1, index2, index3)
            dump_track(name, bend_track("%s.%07i" % (prefix, index1), "%s.%07i" % (prefix, index2), "%s.%07i" % (prefix, index3), sub))
            log("DONE %s" % name)
        except TrackNotFoundError, e:
            log("WARNING %s" % str(e))
for index1, index2, index3, index4 in psf.dihedrals:
    if atom_filter(index1, index2, index3, index4):
        try:
            name = '%s.dihed.%07i.%07i.%07i.%07i' % (prefix, index1, index2, index3, index4)
            dump_track(name, dihed_track("%s.%07i" % (prefix, index1), "%s.%07i" % (prefix, index2), "%s.%07i" % (prefix, index3), "%s.%07i" % (prefix, index4), sub))
            log("DONE %s" % name)
        except TrackNotFoundError, e:
            log("WARNING %s" % str(e))


