#!/usr/bin/python
# Tracks provides tools for analyzing large trajectory files.
# Copyright (C) 2007 Toon Verstraelen <Toon.Verstraelen@UGent.be>
#
# This file is part of Tracks.
#
# Tracks is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# Tracks is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
# --


from tracks.util import dist_track, bend_track, dihed_track
from tracks.core import dump_track, TrackNotFoundError
from tracks.parse import parse_slice
from tracks.util import AtomFilter
from tracks.log import log
from ccio.psf import PSFFile

import numpy
from optparse import OptionParser


usage = """%prog [options] prefix kind [atoms1 atoms2 [atoms3 [atoms4]]] connectivity.psf

%prog computes all the internal coordinates of the given ${kind} for the
Cartesian tracks with the given ${prefix}. ${kind} can be one of 'bond', 'bend'
or 'dihed'. The cartesian tracks are supposed to have the following filenames:
${prefix}.${index}.${c}, where ${index} is the atom index padded with zeros up
to 7 characters and ${x} is x, y or z.

The list of internal coordinates is taken from the file ${connectivity.psf}.
Optionally one can reduce the internal coordinates to those that belong to the
given set of atoms. Each ${atoms*} argument is a comma-separated list of atom
indexes.

Case ${kind}=bond

The output is written to: ${prefix}.bond.${index1}.${index2}
Only two or none ${atoms*} arguments are allowed. If the ${atoms1} and ${atoms2}
arguments are given, only bond lengths between an atom from ${atoms1} and and
atom from ${atoms2} are considered.

Case ${kind}=bend

The output is written to ${prefix}.bend.${index1}.${index2}.${index3}
Only three or none ${atoms*} arguments are allowed. Their interpretation is
similar to the bond case.

Case ${kind}=dihed

The output is written to ${prefix}.dihed.${index1}.${index2}.${index3}.${index4}
Only four or none ${atoms*} arguments are allowed. Their interpretation is
similar to the bond case.

%prog -h prints out all available options."""

parser = OptionParser(usage)
parser.add_option(
    "-s", "--slice", default="::",
    help="Subsample the input tracks with the given slice start:stop:step "
         "where start, stop and step must be integers or can be omitted. "
         "The slice interpretation is pythonic. [default=%default]",
)
parser.add_option(
    "-o", "--output-prefix",
    help="Use this prefix for the output files, if not given the prefix of the"
         "Cartesian coordinate tracks is used.",
)
parser.add_option(
    "-q", "--quiet", action="store_false", dest="verbose", default=True,
    help="Don't print any output."
)
(options, args) = parser.parse_args()


log.verbose = options.verbose
if len(args) >= 3:
    prefix = args[0]
    kind = args[1].lower()
    path_psf = args[-1]
else:
    parser.error("Expecting at least three arguments.")

sub = parse_slice(options.slice)
psf = PSFFile(path_psf)
if options.output_prefix is None:
    output_prefix = prefix
else:
    output_prefix = options.output_prefix

if kind == 'bond':
    if len(args) == 3:
        atom_filter1 = AtomFilter()
        atom_filter2 = AtomFilter()
    elif len(args) == 5:
        atom_filter1 = AtomFilter(args[-3])
        atom_filter2 = AtomFilter(args[-2])
    else:
        parser.error("When kind is bond, three or five arguments are expected, got %i." % len(args))

    for index1, index2 in psf.bonds:
        if ((atom_filter1(index1) and atom_filter2(index2)) or
            (atom_filter1(index2) and atom_filter2(index1))):
            try:
                name = '%s.bond.%07i.%07i' % (output_prefix, index1, index2)
                dump_track(name, dist_track("%s.%07i" % (prefix, index1), "%s.%07i" % (prefix, index2), sub))
                log("DONE %s" % name)
            except TrackNotFoundError, e:
                log("WARNING %s" % str(e))

elif kind == 'bend':
    if len(args) == 3:
        atom_filter1 = AtomFilter()
        atom_filter2 = AtomFilter()
        atom_filter3 = AtomFilter()
    elif len(args) == 6:
        atom_filter1 = AtomFilter(args[-4])
        atom_filter2 = AtomFilter(args[-3])
        atom_filter3 = AtomFilter(args[-2])
    else:
        parser.error("When kind is bond, three or six arguments are expected, got %i." % len(args))

    for index1, index2, index3 in psf.bends:
        if ((atom_filter1(index1) and atom_filter2(index2) and atom_filter3(index3)) or
            (atom_filter1(index3) and atom_filter2(index2) and atom_filter3(index1))):
            try:
                name = '%s.bend.%07i.%07i.%07i' % (output_prefix, index1, index2, index3)
                dump_track(name, bend_track("%s.%07i" % (prefix, index1), "%s.%07i" % (prefix, index2), "%s.%07i" % (prefix, index3), sub))
                log("DONE %s" % name)
            except TrackNotFoundError, e:
                log("WARNING %s" % str(e))

elif kind == 'dihed':
    if len(args) == 3:
        atom_filter1 = AtomFilter()
        atom_filter2 = AtomFilter()
        atom_filter3 = AtomFilter()
        atom_filter4 = AtomFilter()
    elif len(args) == 7:
        atom_filter1 = AtomFilter(args[-5])
        atom_filter2 = AtomFilter(args[-4])
        atom_filter3 = AtomFilter(args[-3])
        atom_filter4 = AtomFilter(args[-2])
    else:
        parser.error("When kind is bond, three or seven arguments are expected, got %i." % len(args))

    for index1, index2, index3, index4 in psf.dihedrals:
        if ((atom_filter1(index1) and atom_filter2(index2) and atom_filter3(index3) and atom_filter4(index4)) or
            (atom_filter1(index4) and atom_filter2(index3) and atom_filter3(index2) and atom_filter4(index1))):
            try:
                name = '%s.dihed.%07i.%07i.%07i.%07i' % (output_prefix, index1, index2, index3, index4)
                dump_track(name, dihed_track("%s.%07i" % (prefix, index1), "%s.%07i" % (prefix, index2), "%s.%07i" % (prefix, index3), "%s.%07i" % (prefix, index4), sub))
                log("DONE %s" % name)
            except TrackNotFoundError, e:
                log("WARNING %s" % str(e))

else:
    parser.error("Unknown kind: %s" % kind)


