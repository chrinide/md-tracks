#!/usr/bin/python
# Tracks provides tools for analyzing large trajectory files.
# Copyright (C) 2007 Toon Verstraelen <Toon.Verstraelen@UGent.be>
#
# This file is part of Tracks.
#
# Tracks is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# Tracks is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
# --


from tracks.core import dump_track, TrackNotFoundError
from tracks.parse import parse_slice
from tracks.util import AtomFilter
from tracks.log import log
import tracks.vector as vector
from ccio.psf import PSFFile

import numpy
from optparse import OptionParser


usage = """%prog [options] prefix kind [atoms1 atoms2 [atoms3 [atoms4]]] connectivity.psf

%prog computes all the internal coordinates of the given ${kind} for the
Cartesian tracks with the given ${prefix}. ${kind} can be one of 'bond', 'bend'
or 'dihed'. The cartesian tracks are supposed to have the following filenames:
${prefix}.${index}.${c}, where ${index} is the atom index padded with zeros up
to 7 characters and ${x} is x, y or z.

The list of internal coordinates is taken from the file ${connectivity.psf}.
Optionally one can reduce the internal coordinates to those that belong to the
given set of atoms. Each ${atoms*} argument is a comma-separated list of atom
indexes.

Case ${kind}=bond

The output is written to: ${prefix}.bond.${index1}.${index2}
Only two or none ${atoms*} arguments are allowed. If the ${atoms1} and ${atoms2}
arguments are given, only bond lengths between an atom from ${atoms1} and and
atom from ${atoms2} are considered.

Case ${kind}=bend

The output is written to ${prefix}.bend.${index1}.${index2}.${index3}
Only three or none ${atoms*} arguments are allowed. Their interpretation is
similar to the bond case.

Case ${kind}=dihed

The output is written to ${prefix}.dihed.${index1}.${index2}.${index3}.${index4}
Only four or none ${atoms*} arguments are allowed. Their interpretation is
similar to the bond case.

Case ${kind}=dtl (Distance to line, (1,2)-3)

The output is written to ${prefix}.dtl.${index1}.${index2}.${index3}
Only three or none ${atoms*} arguments are allowed. Their interpretation is
similar to the bond case.

Case ${kind}=oop (Out of plane distance, (1,2,3)-4)

The output is written to ${prefix}.oop.${index1}.${index2}.${index3}.${index4}
Only four or none ${atoms*} arguments are allowed. Their interpretation is
similar to the bond case.

%prog -h prints out all available options."""

parser = OptionParser(usage)
parser.add_option(
    "-s", "--slice", default="::",
    help="Subsample the input tracks with the given slice start:stop:step "
         "where start, stop and step must be integers or can be omitted. "
         "The slice interpretation is pythonic. [default=%default]",
)
parser.add_option(
    "-o", "--output-prefix",
    help="Use this prefix for the output files, if not given the prefix of the"
         "Cartesian coordinate tracks is used.",
)
parser.add_option(
    "-q", "--quiet", action="store_false", dest="verbose", default=True,
    help="Don't print any output."
)
parser.add_option(
    "-c", "--cos", action="store_true", default=False,
    help="Compute the cosine instead of the angle."
)
(options, args) = parser.parse_args()


log.verbose = options.verbose
if len(args) >= 3:
    prefix = args[0]
    kind = args[1].lower()
    path_psf = args[-1]
else:
    parser.error("Expecting at least three arguments.")

sub = parse_slice(options.slice)
psf = PSFFile(path_psf)
if options.output_prefix is None:
    output_prefix = prefix
else:
    output_prefix = options.output_prefix

if kind == 'bond':
    if len(args) == 3:
        atom_filter1 = AtomFilter()
        atom_filter2 = AtomFilter()
    elif len(args) == 5:
        atom_filter1 = AtomFilter(args[-3])
        atom_filter2 = AtomFilter(args[-2])
    else:
        parser.error("When kind is bond, three or five arguments are expected, got %i." % len(args))

    for index1, index2 in psf.bonds:
        if ((atom_filter1(index1) and atom_filter2(index2)) or
            (atom_filter1(index2) and atom_filter2(index1))):
            try:
                name = '%s.bond.%07i.%07i' % (output_prefix, index1, index2)
                dump_track(name, vector.dist(
                    vector.from_prefix("%s.%07i" % (prefix, index1), sub),
                    vector.from_prefix("%s.%07i" % (prefix, index2), sub),
                ))
                log("DONE %s" % name)
            except TrackNotFoundError, e:
                log("WARNING %s" % str(e))

elif kind == 'bend':
    if len(args) == 3:
        atom_filter1 = AtomFilter()
        atom_filter2 = AtomFilter()
        atom_filter3 = AtomFilter()
    elif len(args) == 6:
        atom_filter1 = AtomFilter(args[-4])
        atom_filter2 = AtomFilter(args[-3])
        atom_filter3 = AtomFilter(args[-2])
    else:
        parser.error("When kind is bend, three or six arguments are expected, got %i." % len(args))

    for index1, index2, index3 in psf.bends:
        if ((atom_filter1(index1) and atom_filter2(index2) and atom_filter3(index3)) or
            (atom_filter1(index3) and atom_filter2(index2) and atom_filter3(index1))):
            try:
                name = '%s.bend.%07i.%07i.%07i' % (output_prefix, index1, index2, index3)
                dump_track(name, vector.bend(
                    vector.from_prefix("%s.%07i" % (prefix, index1), sub),
                    vector.from_prefix("%s.%07i" % (prefix, index2), sub),
                    vector.from_prefix("%s.%07i" % (prefix, index3), sub),
                    return_cos=options.cos,
                ))
                log("DONE %s" % name)
            except TrackNotFoundError, e:
                log("WARNING %s" % str(e))

elif kind == 'dihed':
    if len(args) == 3:
        atom_filter1 = AtomFilter()
        atom_filter2 = AtomFilter()
        atom_filter3 = AtomFilter()
        atom_filter4 = AtomFilter()
    elif len(args) == 7:
        atom_filter1 = AtomFilter(args[-5])
        atom_filter2 = AtomFilter(args[-4])
        atom_filter3 = AtomFilter(args[-3])
        atom_filter4 = AtomFilter(args[-2])
    else:
        parser.error("When kind is dihed, three or seven arguments are expected, got %i." % len(args))

    for index1, index2, index3, index4 in psf.dihedrals:
        if ((atom_filter1(index1) and atom_filter2(index2) and atom_filter3(index3) and atom_filter4(index4)) or
            (atom_filter1(index4) and atom_filter2(index3) and atom_filter3(index2) and atom_filter4(index1))):
            try:
                name = '%s.dihed.%07i.%07i.%07i.%07i' % (output_prefix, index1, index2, index3, index4)
                dump_track(name, vector.dihed(
                    vector.from_prefix("%s.%07i" % (prefix, index1), sub),
                    vector.from_prefix("%s.%07i" % (prefix, index2), sub),
                    vector.from_prefix("%s.%07i" % (prefix, index3), sub),
                    vector.from_prefix("%s.%07i" % (prefix, index4), sub),
                    return_cos=options.cos,
                ))
                log("DONE %s" % name)
            except TrackNotFoundError, e:
                log("WARNING %s" % str(e))

elif kind == 'dtl':
    from molmod.graphs import MatchGenerator, SubgraphMatchDefinition, Graph

    if len(args) == 3:
        atom_filter1 = AtomFilter()
        atom_filter2 = AtomFilter()
        atom_filter3 = AtomFilter()
    elif len(args) == 6:
        atom_filter1 = AtomFilter(args[-4])
        atom_filter2 = AtomFilter(args[-3])
        atom_filter3 = AtomFilter(args[-2])
    else:
        parser.error("When kind is dtl, three or six arguments are expected, got %i." % len(args))

    graph = psf.get_graph()
    match_generator = MatchGenerator(SubgraphMatchDefinition(
        Graph([(1,2),(1,3)]),
        node_tags = {1: 1, 2: 2, 3: 3}
    ))

    for match in match_generator(graph):
        index1 = match.forward[1]
        index2 = match.forward[2]
        index3 = match.forward[3]
        if atom_filter1(index1) and atom_filter2(index2) and atom_filter3(index3):
            try:
                name = '%s.dtl.%07i.%07i.%07i' % (output_prefix, index1, index2, index3)
                dump_track(name, vector.dtl(
                    vector.from_prefix("%s.%07i" % (prefix, index1), sub),
                    vector.from_prefix("%s.%07i" % (prefix, index2), sub),
                    vector.from_prefix("%s.%07i" % (prefix, index3), sub),
                ))
                log("DONE %s" % name)
            except TrackNotFoundError, e:
                log("WARNING %s" % str(e))

elif kind == 'oop':
    from molmod.graphs import MatchGenerator, SubgraphMatchDefinition, CriteriaSet, Graph

    if len(args) == 3:
        atom_filter1 = AtomFilter()
        atom_filter2 = AtomFilter()
        atom_filter3 = AtomFilter()
        atom_filter4 = AtomFilter()
    elif len(args) == 7:
        atom_filter1 = AtomFilter(args[-5])
        atom_filter2 = AtomFilter(args[-4])
        atom_filter3 = AtomFilter(args[-3])
        atom_filter4 = AtomFilter(args[-2])
    else:
        parser.error("When kind is oop, three or seven arguments are expected, got %i." % len(args))

    graph = psf.get_graph()
    match_generator = MatchGenerator(SubgraphMatchDefinition(
        Graph([(4,1), (4,2), (4,3)]),
        #[CriteriaSet("foo", {1: atom_filter1, 2: atom_filter2, 3: atom_filter3, 4: atom_filter4})],
        [CriteriaSet("foo", {1: atom_filter1, 2: atom_filter2, 3: atom_filter3, 4: atom_filter4})],
    ))

    for match in match_generator(graph):
        index1 = match.forward[1]
        index2 = match.forward[2]
        index3 = match.forward[3]
        index4 = match.forward[4]
        try:
            name = '%s.oop.%07i.%07i.%07i.%07i' % (output_prefix, index1, index2, index3, index4)
            dump_track(name, vector.oop(
                vector.from_prefix("%s.%07i" % (prefix, index1), sub),
                vector.from_prefix("%s.%07i" % (prefix, index2), sub),
                vector.from_prefix("%s.%07i" % (prefix, index3), sub),
                vector.from_prefix("%s.%07i" % (prefix, index4), sub),
            ))
            log("DONE %s" % name)
        except TrackNotFoundError, e:
            log("WARNING %s" % str(e))

else:
    parser.error("Unknown kind: %s" % kind)


