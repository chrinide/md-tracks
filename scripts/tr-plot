#!/usr/bin/python
# Tracks provides tools for analyzing large trajectory files.
# Copyright (C) 2007 Toon Verstraelen <Toon.Verstraelen@UGent.be>
#
# This file is part of Tracks.
#
# Tracks is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# Tracks is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
# --


from tracks.core import load_track
from tracks.parse import parse_slice
from molmod.units import parse_unit

import numpy, sys
from optparse import OptionParser


# A) Specify the parameters and the usage

global_usage = """%prog [global_options] line0 [line1 ...] image

%prog is a generic plotting script that plots data from multiple tracks. The
global options must precede the line specifications. The result is saved to the
file ${image}, which must always be the last argument. A line specification has
the following structure:

 :kind [options] {y|x y [e]}

where ${kind} is 'line' or 'bar', x is the track with the x-data, y is the track
with the y-data and e is the track with the error on the y-data. A line
specification must start with a colon, i.e. ':'.

%prog -h prints the global options.
%prog --line-help print the options for the line specifications."""

global_parser = OptionParser(global_usage)
global_parser.add_option(
    "--line-help",
    help="Print the options for the line specification.",
    default=False, action="store_true",
)
global_parser.add_option(
    "-t", "--title", default="Quick and dirty plot",
    help="The plot title. [default=%default]",
)
global_parser.add_option(
    "-x", "--xlabel", default="X",
    help="The plot xlabel. [default=%default]",
)
global_parser.add_option(
    "-y", "--ylabel", default="Y",
    help="The plot ylabel. [default=%default]",
)
global_parser.add_option(
    "--xlog", default=False, action="store_true",
    help="This option activates a logarithmic scale for the x-axis.",
)
global_parser.add_option(
    "--ylog", default=False, action="store_true",
    help="This option activates a logarithmic scale for the y-axis.",
)
global_parser.add_option(
    "--xinv",
    help="Use the inverse values as labels on the x-axis.",
    default=False, action="store_true",
)
global_parser.add_option(
    "--yinv", default=False, action="store_true",
    help="Use the inverse values as labels on the x-axis.",
)
global_parser.add_option(
    "--xunit", default='au',
    help="The unit for the x-axis. [default=%default]",
)
global_parser.add_option(
    "--yunit", default='au',
    help="The unit for the y-axis. [default=%default]",
)
global_parser.add_option(
    "--xlim", default=",",
    help="The range for the x-axis in the unit defined by XUNIT. "
         "Format: [min],[max]. If min and/or max are omitted, they are set "
         "automatically. [default=%default]",
)
global_parser.add_option(
    "--ylim", default=",",
    help="The range for the y-axis in the unit defined by YUNIT. "
         "Format: [min],[max]. If min and/or max are omitted, they are set "
         "automatically. [default=%default]",
)
global_parser.add_option(
    "--no-legend", action="store_false", dest="legend", default=True,
    help="Hide the legend.",
)
global_parser.add_option(
    "--no-grid", action="store_false", dest="grid", default=True,
    help="Hide the grid.",
)


line_usage = """A line specification has the following structure:

 :kind [options] {y|x y [e]}

where ${kind} is 'line' or 'bar', x is the track with the x-data, y is the track
with the y-data and e is the track with the error on the y-data. A line
specification must start with a colon, i.e. ':'. If the track x contains more
data than y, only the x[:len(y)] will be used for plotting.
"""

line_parser = OptionParser(line_usage)
line_parser.add_option(
    "-c", "--color",
    help="Specifiy the color for this line",
)
line_parser.add_option(
    "-l", "--label",
    help="Specifiy a label for this line",
)
line_parser.add_option(
    "-s", "--slice", default="::",
    help="Subsample the input tracks with the given slice start:stop:step "
         "where start, stop and step must be integers or can be omitted. "
         "The slice interpretation is pythonic. [default=%default]",
)

# B) Define the Data descriptors


class Error(Exception):
    pass


class DataDescriptor(object):
    kinds = {}

    def __new__(type, args):
        result = object.__new__(type, args)
        cls = DataDescriptor.kinds.get(args[0].lower()[1:])
        if cls is None:
            raise Error("line type '%s' not recognized." % args[0])
        else:
            result.__class__ = cls
        return result

    def __init__(self, args):
        (options, args) = line_parser.parse_args(args)
        sub = parse_slice(options.slice)
        del args[0]
        if len(args) == 1:
            self.y = load_track(args[0])[sub]
            self.x = None
            self.error = None
            self.label = args[0]
        elif len(args) == 2:
            if len(args[0]) == 0:
                self.x = None
            else:
                self.x = load_track(args[0])[sub]
            self.y = load_track(args[1])[sub]
            self.error = None
            self.label = args[1]
        elif len(args) == 3:
            if len(args[0]) == 0:
                self.x = None
            else:
                self.x = load_track(args[0])[sub]
            self.y = load_track(args[1])[sub]
            if len(args[2]) == 0:
                self.error = None
            else:
                self.error = load_track(args[2])[sub]
            self.label = args[1]
        else:
            line_parser.error("A line description should at most contain three tracks. Got:\n%s" % " ".join(args))
        if self.x is None:
            self.x = numpy.arange(len(self.y), dtype=float)[sub]
        elif len(self.x) > len(self.y): # allow the x-axis to contain more data
            self.x = self.x[:len(self.y)]
        self.x = self.x/xunit
        self.y = self.y/yunit
        if self.error is not None: self.error = self.error/yunit
        self.color = options.color
        if options.label is not None:
            self.label = options.label


class LineDescriptor(DataDescriptor):

    def plot(self):
        kwargs = {}
        if self.color is not None: kwargs["color"] = self.color
        if self.label is not None: kwargs["label"] = self.label
        self.patch = line = pylab.plot(self.x, self.y, linewidth=1, **kwargs)[0]
        if self.error is not None:
            pylab.plot(self.x, self.y+self.error, linestyle=':', color=line.get_color())
            pylab.plot(self.x, self.y-self.error, linestyle=':', color=line.get_color())

DataDescriptor.kinds["line"] = LineDescriptor


class BarDescriptor(DataDescriptor):

    def plot(self):
        fraction = 0.8
        delta = self.x[1:] - self.x[:-1]
        left = numpy.zeros(len(self.x), float)
        left[1:] = self.x[1:] - 0.5*fraction*delta
        left[0] = self.x[0] - 0.5*fraction*delta[0]
        right = numpy.zeros(len(self.x), float)
        right[:-1] = self.x[:-1] + 0.5*fraction*delta
        right[-1] = self.x[-1] + 0.5*fraction*delta[-1]
        width = right-left
        self.patch = pylab.bar(left, self.y, width, color=self.color, ecolor="k")[0]
        if self.error is not None:
            fraction = 0.5
            left[1:] = self.x[1:] - 0.5*fraction*delta
            left[0] = self.x[0] - 0.5*fraction*delta[0]
            right[:-1] = self.x[:-1] + 0.5*fraction*delta
            right[-1] = self.x[-1] + 0.5*fraction*delta[-1]
            from matplotlib.patches import Polygon
            for l, r, x, y, e in zip(left, right, self.x, self.y, self.error):
                pylab.gca().add_patch(Polygon([(l, y+e),(r,y+e)], ec='k', linewidth=1, fill=False))
                pylab.gca().add_patch(Polygon([(l, y-e),(r,y-e)], ec='k', linewidth=1, fill=False))
                pylab.gca().add_patch(Polygon([(x, y-e),(x,y+e)], ec='k', linewidth=1, fill=False))


DataDescriptor.kinds["bar"] = BarDescriptor


# C) parse the arguments
blocks = [[]]
for word in sys.argv[1:]:
    if word[0] == ":" and word[1:] in DataDescriptor.kinds:
        blocks.append([word])
    else:
        blocks[-1].append(word)

(global_options, global_args) = global_parser.parse_args(blocks[0])
if global_options.line_help:
    line_parser.print_help()

image = blocks[-1][-1]
del blocks[-1][-1]

# D) parse stuff:
xunit = parse_unit(global_options.xunit)
if global_options.xinv: xunit = 1/xunit
yunit = parse_unit(global_options.yunit)
if global_options.yinv: yunit = 1/yunit

def parse_lim(s):
    if s.count(",") != 1:
        raise ValueError("The value of the option xlim and ylim must contain exactly one ','.")
    mi,ma = s.split(',')
    if len(mi) == 0:
        mi = None
    else:
        mi = float(mi)
    if len(ma) == 0:
        ma = None
    else:
        ma = float(ma)
    return mi, ma


import pylab, matplotlib
from matplotlib.ticker import ScalarFormatter
class InvScalarFormatter(ScalarFormatter):
    def __call__(self, x, pos):
        return ScalarFormatter.__call__(self, 1/x, pos)

pylab.clf()
pylab.title(global_options.title)
pylab.xlabel("%s [%s]" % (global_options.xlabel, global_options.xunit))
pylab.ylabel("%s [%s]" % (global_options.ylabel, global_options.yunit))

patches = []
labels = []
if global_options.grid:
    pylab.grid(True,linestyle="-",linewidth=0.2, alpha=0.5)
    pylab.gca().set_axisbelow(True)
for line_block in blocks[1:]:
    dd = DataDescriptor(line_block)
    dd.plot()
    patches.append(dd.patch)
    labels.append(dd.label)
    del dd
if global_options.xlog:
    pylab.gca().set_xscale("log")
if global_options.ylog:
    pylab.gca().set_yscale("log")
if global_options.xinv:
    pylab.gca().get_xaxis().set_major_formatter(InvScalarFormatter())
if global_options.yinv:
    pylab.gca().get_yaxis().set_major_formatter(InvScalarFormatter())
pylab.xlim(parse_lim(global_options.xlim))
pylab.ylim(parse_lim(global_options.ylim))
if global_options.legend:
    pylab.legend(patches, labels, loc=0)
pylab.savefig(image)
