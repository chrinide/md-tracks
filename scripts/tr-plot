#!/usr/bin/python
# Tracks provides tools for analyzing large trajectory files.
# Copyright (C) 2007 Toon Verstraelen <Toon.Verstraelen@UGent.be>
#
# This file is part of Tracks.
#
# Tracks is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# Tracks is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
# --


from tracks.core import load_track
from tracks.parse import parse_slice
from molmod.units import parse_unit

import numpy, sys, pylab
from optparse import OptionParser


# A) Specify the parameters and the usage

global_usage = """%prog [global_options] plot0 [plot1 ...] image

%prog is a generic plotting script that plots data from multiple tracks. The
global options must precede the line specifications. The figure is saved to the
file ${image}, which must always be the last argument. A plot specification has
the following structure:

 :kind [options] data

where ${kind} is 'line' or 'bar'. A plot specification must start with a colon,
i.e. ':'. The available options and the number of data arguments depend on the
kind of plot.

%prog -h prints the global options.
%prog --plot-help print the options for the line specifications."""

global_parser = OptionParser(global_usage)
global_parser.add_option(
    "--plot-help",
    help="Print more information on the plot specifications.",
    default=False, action="store_true",
)
global_parser.add_option(
    "-t", "--title", default="Quick and dirty plot",
    help="The plot title. [default=%default]",
)
global_parser.add_option(
    "-x", "--xlabel", default="X",
    help="The plot xlabel. [default=%default]",
)
global_parser.add_option(
    "-y", "--ylabel", default="Y",
    help="The plot ylabel. [default=%default]",
)
global_parser.add_option(
    "--xlog", default=False, action="store_true",
    help="This option activates a logarithmic scale for the x-axis.",
)
global_parser.add_option(
    "--ylog", default=False, action="store_true",
    help="This option activates a logarithmic scale for the y-axis.",
)
global_parser.add_option(
    "--xinv",
    help="Use the inverse values as labels on the x-axis.",
    default=False, action="store_true",
)
global_parser.add_option(
    "--yinv", default=False, action="store_true",
    help="Use the inverse values as labels on the x-axis.",
)
global_parser.add_option(
    "--xunit", default='au',
    help="The unit for the x-axis. [default=%default]",
)
global_parser.add_option(
    "--yunit", default='au',
    help="The unit for the y-axis. [default=%default]",
)
global_parser.add_option(
    "--xlim", default=",",
    help="The range for the x-axis in the unit defined by XUNIT. "
         "Format: [min],[max]. If min and/or max are omitted, they are set "
         "automatically. [default=%default]",
)
global_parser.add_option(
    "--ylim", default=",",
    help="The range for the y-axis in the unit defined by YUNIT. "
         "Format: [min],[max]. If min and/or max are omitted, they are set "
         "automatically. [default=%default]",
)
global_parser.add_option(
    "--no-legend", action="store_false", dest="legend", default=True,
    help="Hide the legend.",
)
global_parser.add_option(
    "--no-grid", action="store_false", dest="grid", default=True,
    help="Hide the grid.",
)


# B) Define the plot descriptors

class Error(Exception):
    pass


class PlotDescriptor(object):
    kinds = {}

    def __new__(type, args):
        result = object.__new__(type, args)
        cls = PlotDescriptor.kinds.get(args[0].lower()[1:])
        if cls is None:
            raise Error("line type '%s' not recognized." % args[0])
        else:
            result.__class__ = cls
        return result

    def __init__(self, args):
        self.options, self.args = self.parser.parse_args(args[1:])

    def init_line_data(self, xunit, yunit):
        sub = parse_slice(self.options.slice)
        if len(self.args) == 1:
            self.y = load_track(self.args[0])[sub]
            self.x = None
            self.error = None
            label = self.args[0]
        elif len(self.args) == 2:
            if len(self.args[0]) == 0:
                self.x = None
            else:
                self.x = load_track(self.args[0])[sub]
            self.y = load_track(self.args[1])[sub]
            self.error = None
            label = self.args[1]
        elif len(self.args) == 3:
            if len(self.args[0]) == 0:
                self.x = None
            else:
                self.x = load_track(self.args[0])[sub]
            self.y = load_track(self.args[1])[sub]
            if len(self.args[2]) == 0:
                self.error = None
            else:
                self.error = load_track(self.args[2])[sub]
            label = self.args[1]
        else:
            self.parser.error("A line description should at most contain three tracks. Got:\n%s" % " ".join(self.args))
        if self.x is None:
            self.x = numpy.arange(len(self.y), dtype=float)[sub]
        elif len(self.x) > len(self.y): # allow the x-axis to contain more data
            self.x = self.x[:len(self.y)]
        self.x = self.x/xunit
        self.y = self.y/yunit
        if self.error is not None: self.error = self.error/yunit
        if self.options.label is None:
            self.options.label = label


line_usage = """Data arguments: {y|x y [e]}
- x is the track with the x-data
- y is the track with the y-data
- e is the track with the error on the y-data.
If the track x contains more data than y, only the x[:len(y)] will be used for
plotting.
"""
class LineDescriptor(PlotDescriptor):
    parser = OptionParser(line_usage)
    parser.add_option(
        "-c", "--color",
        help="Specifiy the color for this line",
    )
    parser.add_option(
        "-l", "--label",
        help="Specifiy a label for this line",
    )
    parser.add_option(
        "-s", "--slice", default="::",
        help="Subsample the input tracks with the given slice start:stop:step "
             "where start, stop and step must be integers or can be omitted. "
             "The slice interpretation is pythonic. [default=%default]",
    )

    def __init__(self, args):
        PlotDescriptor.__init__(self, args)

    def plot(self, xunit, yunit):
        self.init_line_data(xunit, yunit)
        kwargs = {}
        if self.options.color is not None: kwargs["color"] = self.options.color
        self.patch = pylab.plot(self.x, self.y, linewidth=1, **kwargs)[0]
        self.options.color = self.patch.get_color()
        if self.error is not None:
            pylab.plot(self.x, self.y+self.error, linestyle='-', alpha=0.5, color=self.options.color)
            pylab.plot(self.x, self.y-self.error, linestyle='-', alpha=0.5, color=self.options.color)

PlotDescriptor.kinds["line"] = LineDescriptor


class BarDescriptor(PlotDescriptor):
    parser = LineDescriptor.parser

    def plot(self, xunit, yunit):
        self.init_line_data(xunit, yunit)
        fraction = 1.0
        delta = self.x[1:] - self.x[:-1]
        left = numpy.zeros(len(self.x), float)
        left[1:] = self.x[1:] - 0.5*fraction*delta
        left[0] = self.x[0] - 0.5*fraction*delta[0]
        right = numpy.zeros(len(self.x), float)
        right[:-1] = self.x[:-1] + 0.5*fraction*delta
        right[-1] = self.x[-1] + 0.5*fraction*delta[-1]
        width = right-left

        points_x = []
        points_y = []
        for index in xrange(len(self.y)):
            points_x.append(left[index])
            points_y.append(self.y[index])
            points_x.append(right[index])
            points_y.append(self.y[index])
        kwargs = {}
        if self.options.color is not None: kwargs["color"] = self.options.color
        self.patch = pylab.plot(points_x, points_y, linewidth=1, **kwargs)[0]
        self.options.color = self.patch.get_color()
        if self.error is not None:
            from matplotlib.patches import Polygon
            fraction = 0.5
            left[1:] = self.x[1:] - 0.5*fraction*delta
            left[0] = self.x[0] - 0.5*fraction*delta[0]
            right[:-1] = self.x[:-1] + 0.5*fraction*delta
            right[-1] = self.x[-1] + 0.5*fraction*delta[-1]
            for l, r, x, y, e in zip(left, right, self.x, self.y, self.error):
                pylab.gca().add_patch(Polygon([(l, y+e),(r,y+e)], ec=self.options.color, alpha=0.5, linewidth=1, fill=False))
                pylab.gca().add_patch(Polygon([(l, y-e),(r,y-e)], ec=self.options.color, alpha=0.5, linewidth=1, fill=False))
                pylab.gca().add_patch(Polygon([(x, y-e),(x,y+e)], ec=self.options.color, alpha=0.5, linewidth=1, fill=False))
        pylab.gca().autoscale_view()

PlotDescriptor.kinds["bar"] = BarDescriptor


straigt_line_usage = """The data argument is a single value for the position of the line.

The unit must be included, e.g. 3*A.
"""
class StraightHLineDescriptor(PlotDescriptor):
    parser = OptionParser(straigt_line_usage)
    parser.add_option(
        "-c", "--color", default='k',
        help="Specifiy the color for this line [default=%default]",
    )
    parser.add_option(
        "-l", "--label",
        help="Specifiy a label for this line",
    )
    kind = None

    def __init__(self, args):
        PlotDescriptor.__init__(self, args)
        if len(self.args) != 1:
            self.parser.error("Expecting one argument in %s specification" % self.kind)
        else:
            self.value = parse_unit(self.args[0])


class HLineDescriptor(StraightHLineDescriptor):
    kind = "hline"

    def plot(self, xunit, yunit):
        kwargs = {}
        if self.options.color is not None: kwargs["color"] = self.options.color
        self.patch = pylab.axhline(self.value/yunit, linewidth=1, **kwargs)

PlotDescriptor.kinds["hline"] = HLineDescriptor


class VLineDescriptor(StraightHLineDescriptor):
    kind = "vline"

    def plot(self, xunit, yunit):
        kwargs = {}
        if self.options.color is not None: kwargs["color"] = self.options.color
        self.patch = pylab.axvline(self.value/xunit, linewidth=1, **kwargs)

PlotDescriptor.kinds["vline"] = VLineDescriptor



# C) parse the arguments
blocks = [[]]
for word in sys.argv[1:]:
    if word[0] == ":" and word[1:] in PlotDescriptor.kinds:
        blocks.append([word])
    else:
        blocks[-1].append(word)

(global_options, global_args) = global_parser.parse_args(blocks[0])
if global_options.plot_help:
    global_parser.print_usage()
    print
    print "Plot specifications"
    print "==================="
    print
    for name, cls in sorted(PlotDescriptor.kinds.iteritems()):
        print name
        print "-"*len(name)
        cls.parser.print_help()
    sys.exit(0)
if len(global_args) > 0:
    parser.error("Expecting no global arguments. Got %s" % global_args)

image = blocks[-1][-1]
del blocks[-1][-1]

# D) parse stuff:
xunit = parse_unit(global_options.xunit)
if global_options.xinv: xunit = 1/xunit
yunit = parse_unit(global_options.yunit)
if global_options.yinv: yunit = 1/yunit

def parse_lim(s):
    if s.count(",") != 1:
        raise ValueError("The value of the option xlim and ylim must contain exactly one ','.")
    mi,ma = s.split(',')
    if len(mi) == 0:
        mi = None
    else:
        mi = float(mi)
    if len(ma) == 0:
        ma = None
    else:
        ma = float(ma)
    return mi, ma


# E) The actual plotting
from matplotlib.ticker import ScalarFormatter
class InvScalarFormatter(ScalarFormatter):
    def __call__(self, x, pos):
        return ScalarFormatter.__call__(self, 1/x, pos)

pylab.clf()
pylab.title(global_options.title)
pylab.xlabel("%s [%s]" % (global_options.xlabel, global_options.xunit))
pylab.ylabel("%s [%s]" % (global_options.ylabel, global_options.yunit))

patches = []
labels = []
if global_options.grid:
    pylab.grid(True,linestyle="-",linewidth=0.2, alpha=0.5)
    pylab.gca().set_axisbelow(True)
for line_block in blocks[1:]:
    dd = PlotDescriptor(line_block)
    dd.plot(xunit, yunit)
    if dd.options.label is not None:
        patches.append(dd.patch)
        labels.append(dd.options.label)
    del dd
if global_options.xlog:
    pylab.gca().set_xscale("log")
if global_options.ylog:
    pylab.gca().set_yscale("log")
if global_options.xinv:
    pylab.gca().get_xaxis().set_major_formatter(InvScalarFormatter())
if global_options.yinv:
    pylab.gca().get_yaxis().set_major_formatter(InvScalarFormatter())
pylab.xlim(parse_lim(global_options.xlim))
pylab.ylim(parse_lim(global_options.ylim))
if global_options.legend:
    pylab.legend(patches, labels, loc=0)
pylab.savefig(image)
