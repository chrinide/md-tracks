#!/usr/bin/python
# Tracks provides tools for analyzing large trajectory files.
# Copyright (C) 2007 Toon Verstraelen <Toon.Verstraelen@UGent.be>
#
# This file is part of Tracks.
#
# Tracks is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# Tracks is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
# --


import numpy, sys


class Model(object):
    def get_parameters(self):
        raise NotImplementedError

    def set_parameters(self, parameters):
        raise NotImplementedError

    def __call__(self, f):
        raise NotImplementedError

    def gradient(self, f):
        raise NotImplementedError


class GaussianModel(Model):
    def __init__(self, parameters):
        assert parameters.shape == (3,)
        self.parameters = parameters

    def get_parameters(self):
        return tuple(self.parameters)

    def set_parameters(self, parameters):
        assert parameters.shape == (3,)
        self.parameters = parameters.copy()

    def get_labels(self):
        return 'lc', 'sigma', 'A'

    def __call__(self, l):
        lc, sigma, A = self.get_parameters()
        return A*numpy.exp(-((l - lc)/sigma)**2)

    def gradient(self, l):
        lc, sigma, A = self.get_parameters()
        x = (l - lc)/sigma
        g = numpy.exp(-x**2)
        return numpy.array([
            A*g*2*x/sigma,
            A*g*2*x**2/sigma,
            g,
        ], float)

    def hessian(self, l):
        lc, sigma, A = self.get_parameters()
        x = (l - lc)/sigma
        g = numpy.exp(-x**2)
        result = numpy.zeros((3,3,len(l)),float)
        result[0,0] = A*g*2/sigma**2*(2*x**2-1)
        result[0,1] = A*g*4*x/sigma**2*(x**2-1)#A*g*2*(x/sigma)**2*(2*x-3)
        result[1,0] = result[0,1]
        result[0,2] = g*2*x/sigma
        result[2,0] = result[0,2]
        result[1,1] = A*g*2*(x/sigma)**2*(2*x**2-3)
        result[1,2] = g*2*x**2/sigma
        result[2,1] = result[1,2]
        result[2,2] = 0
        return result


class PeakModel(Model):
    def __init__(self, parameters=None):
        if parameters is None:
            self.b = 0
            self.gaussians = [GaussianModel()]
        else:
            self.b = parameters[0]
            num_gaussians = (len(parameters)-1)/3
            self.gaussians = [GaussianModel(parameters[index*3+1:index*3+4]) for index in xrange(num_gaussians)]

    def get_parameters(self):
        result = (self.b,)
        for gaussian in self.gaussians:
            result += gaussian.get_parameters()
        return result

    def set_parameters(self, parameters):
        self.b = parameters[0]
        for index, gaussian in enumerate(self.gaussians):
            gaussian.set_parameters(parameters[1+index*3:4+index*3])

    def get_labels(self):
        return ('b',) + sum((gaussian.get_labels() for gaussian in self.gaussians), ())

    def __call__(self, l):
        return self.b+sum(gaussian(l) for gaussian in self.gaussians)

    def gradient(self, l):
        return numpy.array([
            numpy.ones(len(l), float)
        ] + sum(
            (list(gaussian.gradient(l)) for gaussian in self.gaussians)
        , []))

    def hessian(self, l):
        num_parameters = len(self.get_parameters())
        result = numpy.zeros((num_parameters,num_parameters,len(l)), float)
        for index, gaussian in enumerate(self.gaussians):
            result[index*3+1:index*3+4,index*3+1:index*3+4] = gaussian.hessian(l)
        return result


class FitCostFunction(object):
    def __init__(self, wavenumbers, amplitudes, peak_model):
        self.wavenumbers = wavenumbers
        self.amplitudes = amplitudes
        self.peak_model = peak_model

    def __call__(self, parameters):
        self.peak_model.set_parameters(parameters)
        return ((self.peak_model(self.wavenumbers)-self.amplitudes)**2).mean()

    def gradient(self, parameters):
        self.peak_model.set_parameters(parameters)
        return 2*numpy.dot(self.peak_model.gradient(self.wavenumbers), (self.peak_model(self.wavenumbers)-self.amplitudes))/len(self.wavenumbers)

    def hessian(self, parameters):
        errors = (self.peak_model(self.wavenumbers) - self.amplitudes)
        mg = self.peak_model.gradient(self.wavenumbers)
        mh = self.peak_model.hessian(self.wavenumbers)
        result = numpy.zeros((len(parameters),len(parameters)), float)
        for index1 in xrange(len(parameters)):
            for index2 in xrange(len(parameters)):
                result[index1,index2] = numpy.dot(mg[index1],mg[index2]) + numpy.dot(errors,mh[index1,index2])
        return 2*result/len(self.wavenumbers)



import sys
from tracks import load_track, dump_track, log
from optparse import OptionParser
from molmod.units import parse_unit


usage = """Usage: %prog [options] wavenumbers amplitudes minwn maxwn initial_parameters

%prog fits a model to a given spectrum.

The mandatory arguments are the following:
  wavenumbers -- the track with the wavenumbers
  amplitudes -- the amplitudes of the vibrational spectrum
  minwn -- the beginning of the fitting window
  maxwn -- the end of the fitting window
  initial_parameters -- The initial model parameters: b:lc_0:sigma_0:A_0[:lc_1:sigma_1:A_1:...]

The model has the following analytical form:

amplitude(l) = b + sum_i A_i*exp(-((l-lc_i)/sigma_i)**2)

%prog -h prints out all available options."""

parser = OptionParser(usage)
parser.add_option(
    "--test", default=False, action="store_true",
    help="Perform some internal consistency tests of the fitting program, "
         "using the given data.",
)
parser.add_option(
    "--no-fit", default=True, action="store_false", dest="fit",
    help="Do not optimize the parameters.",
)
parser.add_option(
    "--dump-model", dest="model_path",
    help="Dump the aplitudes track from the optimized model to MODEL_PATH.",
)
parser.add_option(
    "--xunit", default='1/cm',
    help="The unit for the x-data. [default=%default]",
)
parser.add_option(
    "--yunit", default='au',
    help="The unit for the y-data. [default=%default]",
)
parser.add_option(
    "-q", "--quiet", action="store_false", dest="verbose", default=True,
    help="Don't print any output."
)
(options, args) = parser.parse_args()


xunit = parse_unit(options.xunit)
yunit = parse_unit(options.yunit)

log.verbose = options.verbose
if len(args) == 5:
    path_wavenumbers, path_amplitudes, minfreq, maxfreq, initps = args
    minfreq = float(minfreq)
    maxfreq = float(maxfreq)
    initial_parameters = numpy.array([float(word) for word in initps.split(":")])
else:
    parser.error("Expecting five arguments")

# manipulate the training data
all_wavenumbers = load_track(path_wavenumbers)/xunit
all_amplitudes = load_track(path_amplitudes)/yunit
begin,end = all_wavenumbers.searchsorted([minfreq, maxfreq])
wavenumbers = all_wavenumbers[begin:end]
amplitudes = all_amplitudes[begin:end]

# create the model
peak_model = PeakModel(initial_parameters)

# create the cost function
cost_function = FitCostFunction(wavenumbers, amplitudes, peak_model)

if options.test:
    import unittest
    class ConsistencyTestCase(unittest.TestCase):
        def test_model_gradient(self):
            peak_model.set_parameters(initial_parameters)
            epsilon = 1e-5
            ag = peak_model.gradient(wavenumbers) # analytical gradient
            for index in xrange(len(initial_parameters)):
                tmp = initial_parameters.copy()
                tmp[index] -= 0.5*epsilon
                peak_model.set_parameters(tmp)
                m = peak_model(wavenumbers)
                tmp = initial_parameters.copy()
                tmp[index] += 0.5*epsilon
                peak_model.set_parameters(tmp)
                p = peak_model(wavenumbers)
                #print "target = (p-m)/epsilon"
                target = (p-m)/epsilon
                #print target
                #print "outcome = ag[index]"
                outcome = ag[index]
                #print outcome
                #print "ratio = outcome/target"
                #print outcome/target
                error = abs((p-m)/epsilon - ag[index]).max()
                oom = abs(ag[index]).max()
                #print error,oom
                self.assert_(error/oom < 1e-2, "model gradient incorrect, parameter %i" % index)

        def test_model_hessian(self):
            peak_model.set_parameters(initial_parameters)
            epsilon = 1e-5
            ah = peak_model.hessian(wavenumbers) # analytical hessian
            for index1 in xrange(len(initial_parameters)):
                tmp = initial_parameters.copy()
                tmp[index1] -= 0.5*epsilon
                peak_model.set_parameters(tmp)
                m = peak_model.gradient(wavenumbers)
                tmp = initial_parameters.copy()
                tmp[index1] += 0.5*epsilon
                peak_model.set_parameters(tmp)
                p = peak_model.gradient(wavenumbers)
                for index2 in xrange(len(initial_parameters)):
                    #print "index1 index2 =", index1, index2
                    #print "target = (p[index2]-m[index2])/epsilon"
                    target = (p[index2]-m[index2])/epsilon
                    #print target
                    #print "outcome = ah[index1,index2]"
                    outcome = ah[index1,index2]
                    #print outcome
                    #print "target/outcome"
                    #print target/outcome
                    error = abs(outcome - target).max()
                    oom = abs(target).max()
                    #print error,oom
                    if oom == 0:
                        self.assert_(error < epsilon, "model hessian incorrect, parameters (%i,%i)" % (index1,index2))
                    else:
                        self.assert_(error/oom < 1e-2, "model hessian incorrect, parameters (%i,%i)" % (index1,index2))

        def test_cost_gradient(self):
            epsilon = 1e-5
            ag = cost_function.gradient(initial_parameters) # analytical gradient
            for index in xrange(len(initial_parameters)):
                tmp = initial_parameters.copy()
                tmp[index] -= 0.5*epsilon
                m = cost_function(tmp)
                tmp = initial_parameters.copy()
                tmp[index] += 0.5*epsilon
                p = cost_function(tmp)
                #print "(p-m)/epsilon"
                #print (p-m)/epsilon
                #print "ag[index]"
                #print ag[index]
                #print "ratio"
                #print ag[index]/(p-m)/epsilon
                error = abs((p-m)/epsilon - ag[index]).max()
                oom = abs(ag[index]).max()
                #print error,oom
                self.assert_(error/oom < 1e-2, "model gradient incorrect, parameter %i" % index)

        def test_cost_hessian(self):
            epsilon = 1e-5
            ah = cost_function.hessian(initial_parameters) # analytical hessian
            for index1 in xrange(len(initial_parameters)):
                tmp = initial_parameters.copy()
                tmp[index1] -= 0.5*epsilon
                m = cost_function.gradient(tmp)
                tmp = initial_parameters.copy()
                tmp[index1] += 0.5*epsilon
                p = cost_function.gradient(tmp)
                for index2 in xrange(len(initial_parameters)):
                    #print "index1 index2 =", index1, index2
                    #print "target = (p[index2]-m[index2])/epsilon"
                    target = (p[index2]-m[index2])/epsilon
                    #print target
                    #print "outcome = ah[index1,index2]"
                    outcome = ah[index1,index2]
                    #print outcome
                    #print "target/outcome"
                    #print target/outcome
                    error = abs(outcome - target).max()
                    oom = abs(target).max()
                    #print error,oom
                    if oom == 0:
                        self.assert_(error < epsilon, "cost hessian incorrect, parameters (%i,%i)" % (index1,index2))
                    else:
                        self.assert_(error/oom < 1e-2, "cost hessian incorrect, parameters (%i,%i)" % (index1,index2))


    unittest.main(argv=sys.argv[:1] + ['-v'])
else:
    from scipy.optimize import fmin_bfgs
    import sys

    log("data range: %i:%i" % (begin,end))
    log("    cost      cond   | %s" % " ".join("%s" % label.center(10) for label in peak_model.get_labels()))
    def log_iteration(current_parameters):
        cost = cost_function(current_parameters)
        hessian = cost_function.hessian(current_parameters)
        evals, evecs = numpy.linalg.eigh(hessian)
        cond = abs(evals).min()/abs(evals).max()
        log(" %1.3e %1.3e | %s" % (cost, cond, " ".join("%10f" % p for p in current_parameters)))
        cond_threshold = 1e-5
        for evl, evc in zip(evals, evecs):
            cond = abs(evl)/abs(evals).max()
            if cond < cond_threshold:
                log("  cond=%1.5e   #" % cond, "_".join("%10f" % value for value in evc))
        sys.stdout.flush()

    ranges = tuple((val*0.9, val*1.1) for val in initial_parameters)
    if options.fit:
        opt_parameters = fmin_bfgs(cost_function, initial_parameters, cost_function.gradient, disp=1, callback=log_iteration)
    else:
        opt_parameters = initial_parameters
        log_iteration(opt_parameters)

    if options.model_path is not None:
        model = peak_model(all_wavenumbers)
        dump_track(options.model_path, model*yunit)

