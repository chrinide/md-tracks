#!/usr/bin/python
# Tracks provides tools for analyzing large trajectory files.
# Copyright (C) 2007 Toon Verstraelen <Toon.Verstraelen@UGent.be>
#
# This file is part of Tracks.
#
# Tracks is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# Tracks is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
# --


from tracks import load_track, parse_slice
from molmod.units import parse_unit
import numpy
from optparse import OptionParser


usage = """%prog [options] {y0|x0 y0 [e0]} [- {y1|x1 y1 [e1]} - ...] image

%prog is a generic plotting script that plots data from multiple tracks. Each
line-plot argument is given in the following format: {y|x y [e]}. Multiple
line-plot arguments are separated by a minus sign. One, two or three tracks can
be given for each line plot:
 * One: y        The track is interpreted as y values. The x values are
                 automatically generated: x=0..N-1 au.
 * Two: x y      A standard line plot.
 * Three: x y e  Similar to the previous case, but also y+e and y-e are plotted.
The figure is saved to ${image}.

%prog -h prints out all available options."""

parser = OptionParser(usage)
parser.add_option(
    "-s", "--slice", default="::",
    help="Subsample the input track(s) with the given slice start:stop:step "
         "where start, stop and step must be integers or can be omitted. "
         "The slice interpretation is pythonic. [default=%default]",
)
parser.add_option(
    "-t", "--title", default="Quick and dirty plot",
    help="The plot title. [default=%default]",
)
parser.add_option(
    "-x", "--xlabel", default="X",
    help="The plot xlabel. [default=%default]",
)
parser.add_option(
    "-y", "--ylabel", default="Y",
    help="The plot ylabel. [default=%default]",
)
parser.add_option(
    "--xlog", default=False, action="store_true",
    help="This option activates a logarithmic scale for the x-axis.",
)
parser.add_option(
    "--ylog", default=False, action="store_true",
    help="This option activates a logarithmic scale for the y-axis.",
)
parser.add_option(
    "--xinv",
    help="Use the inverse values as labels on the x-axis.",
    default=False, action="store_true",
)
parser.add_option(
    "--yinv", default=False, action="store_true",
    help="Use the inverse values as labels on the x-axis.",
)
parser.add_option(
    "--xunit", default='au',
    help="The unit for the x-axis. [default=%default]",
)
parser.add_option(
    "--yunit", default='au',
    help="The unit for the y-axis. [default=%default]",
)
parser.add_option(
    "--xlim", default=",",
    help="The range for the x-axis in the unit defined by XUNIT. "
         "Format: [min],[max]. If min and/or max are omitted, they are set "
         "automatically. [default=%default]",
)
parser.add_option(
    "--ylim", default=",",
    help="The range for the y-axis in the unit defined by YUNIT. "
         "Format: [min],[max]. If min and/or max are omitted, they are set "
         "automatically. [default=%default]",
)
parser.add_option(
    "--no-legend", action="store_false", dest="legend", default=True,
    help="Hide the legend.",
)
(options, args) = parser.parse_args()


sub = parse_slice(options.slice)

# parse the arguments
if len(args) >= 2:
    inputs = " ".join(args[:-1]).split(" - ")
    image = args[-1]
else:
    parser.error("Expecting at least two arguments.")

# parse the units:
xunit = parse_unit(options.xunit)
if options.xinv: xunit = 1/xunit
yunit = parse_unit(options.yunit)
if options.yinv: yunit = 1/yunit

def load_parts(input_expr):
    parts = input_expr.split(' ')
    if len(parts) == 1:
        y = load_track(parts[0])[sub]
        x = None
        error = None
        label = parts[0]
    elif len(parts) == 2:
        if len(parts[0]) == 0:
            x = None
        else:
            x = load_track(parts[0])[sub]
        y = load_track(parts[1])[sub]
        error = None
        label = parts[1]
    elif len(parts) == 3:
        if len(parts[0]) == 0:
            x = None
        else:
            x = load_track(parts[0])[sub]
        y = load_track(parts[1])[sub]
        if len(parts[2]) == 0:
            error = None
        else:
            error = load_track(parts[2])[sub]
        label = parts[1]
    else:
        parser.error("A line plot description should at most contain three tracks.")
    if x is not None: x /= xunit
    if y is not None: y /= yunit
    if error is not None: error /= yunit
    return x, y, error, label

def parse_lim(s):
    if s.count(",") != 1:
        raise ValueError("The value of the option xlim and ylim must contain exactly one ','.")
    mi,ma = s.split(',')
    if len(mi) == 0:
        mi = None
    else:
        mi = float(mi)
    if len(ma) == 0:
        ma = None
    else:
        ma = float(ma)
    return mi, ma


import pylab, matplotlib
from matplotlib.ticker import ScalarFormatter
class InvScalarFormatter(ScalarFormatter):
    def __call__(self, x, pos):
        return ScalarFormatter.__call__(self, 1/x, pos)

pylab.clf()
pylab.title(options.title)
pylab.xlabel("%s [%s]" % (options.xlabel, options.xunit))
pylab.ylabel("%s [%s]" % (options.ylabel, options.yunit))
for input_expr in inputs:
    x,y,error,label = load_parts(input_expr)
    if x is None:
        line = pylab.plot(y, label=label, linewidth=1)[0]
        if error is not None:
            pylab.plot(y+error, label='error on %s' % label, linestyle=':', color=line.get_color())
            pylab.plot(y-error, label='_nolegend_', linestyle=':', color=line.get_color())
    else:
        line = pylab.plot(x, y, label=label, linewidth=1)[0]
        if error is not None:
            pylab.plot(x, y+error, label='error on %s' % label, linestyle=':', color=line.get_color())
            pylab.plot(x, y-error, label='_nolegend_', linestyle=':', color=line.get_color())
pylab.grid(True,linestyle="-",linewidth=0.2, alpha=0.5)
if options.xlog:
    pylab.gca().set_xscale("log")
if options.ylog:
    pylab.gca().set_yscale("log")
if options.xinv:
    pylab.gca().get_xaxis().set_major_formatter(InvScalarFormatter())
if options.yinv:
    pylab.gca().get_yaxis().set_major_formatter(InvScalarFormatter())
pylab.xlim(parse_lim(options.xlim))
pylab.ylim(parse_lim(options.ylim))
if options.legend:
    pylab.legend(loc=0)
pylab.savefig(image)
